# ğŸ“˜ C++ Classes and Objects (OOP Foundations)

This note covers **C++ Classes and Objects** in a **deep, beginner-friendly, and structured way**,  
aligned with **GeeksforGeeks â€“ Classes and Objects** and written to support **DSA + problem solving**.

Reference (for concept alignment):  
ğŸ‘‰ https://www.geeksforgeeks.org/cpp/c-classes-and-objects/

### ğŸ”¹ What is Object-Oriented Programming (OOP)?

Object-Oriented Programming is a programming paradigm that organizes code using:
- **Objects** â†’ real-world entities
- **Classes** â†’ blueprints of objects

### Why OOP?
- Code reusability
- Better structure
- Easier maintenance
- Real-world modeling

![Class vs Object â€“ Instance Creation](../Images/25.png)


### ğŸ”¹ What is a Class in C++?

A **class** is a **user-defined data type** that groups:
- **Data members** (variables)
- **Member functions** (methods)

### Syntax of a Class
```cpp
class ClassName {
    // access specifier
    data members;
    member functions;
};
```

### ğŸ”¹ What is an Object in C++?

An **object** is an **instance of a class**.
It represents a real-world entity created using a class.

> Class = Blueprint
> Object = Actual implementation

### ğŸ”¹ Example: Class and Object (Basic)
```cpp
#include <iostream>
using namespace std;

class Student {
public:
    int roll;
    string name;

    void display() {
        cout << roll << " " << name << endl;
    }
};

int main() {
    Student s1;        // Object creation
    s1.roll = 101;     // Member access
    s1.name = "Alex";

    s1.display();      // Calling member function
    return 0;
}
```

### ğŸ”¹ Creating an Object in C++

**Objects** can be created in **multiple ways**:

### 1ï¸âƒ£ Normal Object Creation
```cpp
Student s1;
```

### 2ï¸âƒ£ Using Pointer
```cpp
Student* s2 = new Student;
s2->roll = 102;
```

### ğŸ”¹ Member Access in C++
| Operator | Used With      |
| -------- | -------------- |
| `.`      | Normal object  |
| `->`     | Pointer object |

### Example
```cpp
s1.roll = 10;   // dot operator
s2->roll = 20; // arrow operator
```

### ğŸ”¹ Access Specifiers in C++
| Specifier   | Accessibility                |
| ----------- | ---------------------------- |
| `public`    | Accessible everywhere        |
| `private`   | Accessible only inside class |
| `protected` | Used in inheritance          |

### Example
```cpp
class Demo {
private:
    int x;

public:
    void set(int a) {
        x = a;
    }
};
```
### ğŸ”¹ Local Class

A **local class** is a class defined **inside a function**.

**Key Points**
* Scope limited to the function
* Cannot have static data members
* Used rarely but important conceptually

### Example
```cpp
#include <iostream>
using namespace std;

void func() {
    class Local {
    public:
        void show() {
            cout << "Local Class" << endl;
        }
    };

    Local obj;
    obj.show();
}

int main() {
    func();
    return 0;
}
```

### ğŸ”¹ Nested Class
A **nested class** is a class defined **inside another class**.

**Key Points**
* Improves logical grouping
* Inner class does NOT automatically access outer class members

### Example
```cpp
#include <iostream>
using namespace std;

class Outer {
public:
    class Inner {
    public:
        void display() {
            cout << "Nested Class" << endl;
        }
    };
};

int main() {
    Outer::Inner obj;
    obj.display();
    return 0;
}
```

### ğŸ”¹ Enum Class (Scoped Enumeration)

Introduced in C++11, `enum class`:
* Avoids name conflicts
* Provides strong type safety

### Normal Enum (Problem)
```cpp
enum Color { RED, BLUE };
enum Traffic { RED, GREEN }; // âŒ conflict
```
### Enum Class (Solution)
```cpp
enum class Color { RED, BLUE };
enum class Traffic { RED, GREEN };
```
### Usage
```cpp
Color c = Color::RED;
```

### ğŸ”¹ Class vs Object (Key Differences)
| Feature     | Class     | Object         |
| ----------- | --------- | -------------- |
| Definition  | Blueprint | Instance       |
| Memory      | No memory | Takes memory   |
| Declaration | Once      | Multiple times |
| Purpose     | Design    | Usage          |

### ğŸ”¹ Difference Between Class and Structure
| Feature        | Class     | Structure |
| -------------- | --------- | --------- |
| Default Access | Private   | Public    |
| OOP Usage      | Preferred | Less used |
| Inheritance    | Supported | Supported |

### ğŸ”¹ Important Notes for DSA
* Most STL containers (`vector`, `map`, etc.) are **classes**
* Understanding **objects & methods** is crucial
* Competitive programming uses OOP heavily

### ğŸ”¹ Common Beginner Mistakes
âŒ Forgetting ; after class

âŒ Using `.` instead of `->` for pointers

âŒ Accessing private members directly

âŒ Confusing class with object

### ğŸ”¹ Summary
* Class = Blueprint
* Object = Real instance
* Member access via `.` or `->`
* Local & Nested classes improve structure
* `enum class` is safer than normal enum
* OOP is **mandatory** for clean C++ & DSA

---

# ğŸ“¦ C++ Standard Template Library (STL) â€“ Complete Beginner to Intermediate Guide

The **Standard Template Library (STL)** is one of the most powerful features of C++.  
Instead of writing your own data structures and algorithms from scratch, STL provides **ready-made, optimized, and type-safe components**.

STL is built using **templates**, which means it works with **any data type**.

---

## ğŸ”¹ Why STL?

STL containers and algorithms are:

- âš¡ Fast and optimized
- âœ… Reliable and well-tested
- ğŸ” Reusable
- ğŸ§  Easy to use
- ğŸ” Type-safe
- â±ï¸ Saves development time

---

## ğŸ”‘ Components of STL

![Components of STL](../Images/26.png)

STL is mainly divided into **3 core components**:

| Component   | Description |
|------------|-------------|
| Containers | Store data |
| Algorithms | Operate on data |
| Iterators  | Connect containers and algorithms |

---

## ğŸ“¦ 1. STL Containers

Containers are **data structures** that store objects in memory.

### ğŸ”¹ Types of Containers

### 1ï¸âƒ£ Sequence Containers  
Store data in **linear order**.

| Container | Description |
|---------|-------------|
| `vector` | Dynamic array |
| `deque` | Double-ended queue |
| `list` | Doubly linked list |
| `forward_list` | Singly linked list |
| `array` | Fixed-size array |


### 2ï¸âƒ£ Container Adaptors  
Provide restricted interfaces over containers.

| Adaptor | Description |
|--------|-------------|
| `stack` | LIFO |
| `queue` | FIFO |
| `priority_queue` | Max/Min heap |

### 3ï¸âƒ£ Associative Containers  
Store data in **sorted order**.

| Container | Description |
|---------|-------------|
| `set` | Unique keys |
| `multiset` | Duplicate keys allowed |
| `map` | Keyâ€“value pairs |
| `multimap` | Duplicate keys allowed |

### 4ï¸âƒ£ Unordered Associative Containers  
Use **hash tables** (faster average time).

| Container |
|----------|
| `unordered_set` |
| `unordered_multiset` |
| `unordered_map` |
| `unordered_multimap` |


#---

# ğŸ“˜ 2. Vector in C++ STL

A **vector** is a **dynamic array** provided by the C++ STL.
Unlike normal arrays, vectors can **grow and shrink automatically**.

### ğŸ§  Why Vector?
Traditional arrays have:
- Fixed size
- Manual memory handling

Vectors solve this by:
- Managing memory internally
- Allowing dynamic resizing

### ğŸ”¹ Key Characteristics of Vector
- Stores elements in **contiguous memory**
- Supports **random access**
- Fast access using index
- Slower insertion/deletion in middle

### ğŸ”¹ Common Vector Operations

| Operation | Description |
|--------|------------|
| `push_back()` | Insert element at end |
| `pop_back()` | Remove last element |
| `size()` | Number of elements |
| `capacity()` | Allocated memory |
| `clear()` | Remove all elements |
| `at()` | Safe element access |
| `[]` | Direct element access |

### âœ… Example Code
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v;

    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    cout << v[1] << endl; // 20

    for(int x : v) {
        cout << x << " ";
    }

    return 0;
}
```

### ğŸŸ¢ Where Vector is Used?
* Dynamic data storage
* Most competitive programming problems
* Graph adjacency lists
* Sliding window problems


## ğŸ“˜ 3. Set in C++ STL
A **set** is an **associative container** that stores:

> **Unique elements in sorted order**

### ğŸ”¹ Key Characteristics of Set
* Elements are **unique**
* Stored in **sorted order**
* Implemented using **Red-Black Tree**
* No indexing (no random access)

### ğŸ”¹ Common Set Operations
| Operation  | Description              |
| ---------- | ------------------------ |
| `insert()` | Insert element           |
| `erase()`  | Remove element           |
| `find()`   | Search element           |
| `count()`  | Check existence (0 or 1) |
| `size()`   | Number of elements       |

### âœ… Example Code
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> s;

    s.insert(30);
    s.insert(10);
    s.insert(20);
    s.insert(10); // duplicate ignored

    for(int x : s) {
        cout << x << " ";
    }
    // Output: 10 20 30

    return 0;
}
```

### ğŸ”¹ Multiset (allows duplicates)
```cpp
multiset<int> ms;
```

### ğŸŸ¢ Where Set is Used?
* Remove duplicates
* Maintain sorted unique data
* Frequency-based problems
* Order statistics


## ğŸ“˜ 4. Map in C++ STL

A **map** stores data in **key-value pairs**.

Each **key** is **unique** and stored in **sorted order**.

### ğŸ§  Think of Map as:

> A real-life dictionary
> Word â†’ Meaning

### ğŸ”¹ Key Characteristics of Map
* Keys are **unique**
* Stored in **sorted order**
* Implemented using **Red-Black Tree**
* Access using keys, not index

### ğŸ”¹ Common Map Operations
| Operation  | Description         |
| ---------- | ------------------- |
| `mp[key]`  | Insert or access    |
| `insert()` | Insert pair         |
| `erase()`  | Remove key          |
| `find()`   | Search key          |
| `count()`  | Check key existence |

### âœ… Example Code
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    map<int, string> mp;

    mp[1] = "Apple";
    mp[3] = "Banana";
    mp[2] = "Orange";

    for(auto it : mp) {
        cout << it.first << " -> " << it.second << endl;
    }

    return 0;
}
```

### ğŸ”¹ Multimap (allows duplicate keys)
```cpp
multimap<int, string> mmp;
```

### ğŸŸ¢ Where Map is Used?
* Frequency counting
* Hash-like problems with ordering
* Key-based lookup problems
* Tree-based problems


## ğŸ“˜ 5. Unordered Map
An **unordered_map** stores key-value pairs but:

> **Does NOT maintain any order**

### ğŸ”¹ Key Characteristics of Unordered Map

* Keys are **unique**
* Stored in **random order**
* Implemented using **Hash Table**
* Faster than map (average O(1))

### ğŸ”¹ Differences: Map vs Unordered Map
| Feature         | Map          | Unordered Map |
| --------------- | ------------ | ------------- |
| Order           | Sorted       | No order      |
| Implementation  | Tree         | Hash table    |
| Time Complexity | O(log n)     | O(1) avg      |
| Use Case        | Ordered data | Fast lookup   |

### âœ… Example Code
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    unordered_map<string, int> um;

    um["apple"] = 2;
    um["banana"] = 5;
    um["orange"] = 3;

    for(auto it : um) {
        cout << it.first << " -> " << it.second << endl;
    }

    return 0;
}
```

### ğŸ”¹ Unordered Multimap
```cpp
unordered_multimap<int, string> ump;
```

### ğŸŸ¢ Where Unordered Map is Used?
* Frequency counting (most common)
* Fast lookups
* Competitive programming
* Hashing-based problems

### ğŸ¯ Key Takeaway (Vector â†’ Set â†’ Map â†’ Unordered Map)
| Container     | Best For              |
| ------------- | --------------------- |
| Vector        | Dynamic arrays        |
| Set           | Unique sorted data    |
| Map           | Sorted key-value      |
| Unordered Map | Fast key-value lookup |

**ğŸ”¥ Mastering these 4 STL containers alone can solve 60â€“70% of DSA problems.**


## ğŸ“˜ 6. Stack in C++ STL (LIFO â€“ Last In First Out)

A **stack** is a container adaptor that follows the **LIFO principle**:
> The element inserted last is removed first.

### ğŸ§  Real-life analogy
Think of a stack of plates:
- You put a plate on top
- You remove the plate from the top

## ğŸ”¹ Key Characteristics of Stack
- No random access (cannot access middle elements)
- Only access the **top element**
- Operations are fast (O(1))

## ğŸ”¹ Common Stack Operations

| Operation | Description |
|---------|-------------|
| `push()` | Insert element at top |
| `pop()` | Remove top element |
| `top()` | Access top element |
| `empty()` | Check if stack is empty |
| `size()` | Number of elements |

### âœ… Example Code
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> st;

    st.push(10);
    st.push(20);
    st.push(30);

    cout << st.top() << endl; // 30

    st.pop(); // removes 30

    cout << st.top() << endl; // 20

    return 0;
}
```

### ğŸŸ¢ Where Stack is Used?
* Function calls (call stack)
* Undo/Redo operations
* Expression evaluation
* Backtracking problems

## ğŸ“˜ 7. Queue in C++ STL (FIFO â€“ First In First Out)

A **queue** follows the **FIFO principle**:

> The element inserted first is removed first.

### ğŸ§  Real-life analogy

Think of a queue at a ticket counter:
* First person enters
* First person gets served

### ğŸ”¹ Common Queue Operations
| Operation | Description               |
| --------- | ------------------------- |
| `push()`  | Insert element at rear    |
| `pop()`   | Remove element from front |
| `front()` | Access front element      |
| `back()`  | Access last element       |
| `empty()` | Check if queue is empty   |

### âœ… Example Code
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;

    q.push(10);
    q.push(20);
    q.push(30);

    cout << q.front() << endl; // 10
    q.pop();

    cout << q.front() << endl; // 20

    return 0;
}
```

### ğŸŸ¢ Where Queue is Used?
* Scheduling tasks
* Breadth First Search (BFS)
* Printer jobs
* CPU scheduling

## ğŸ“˜ 8. Priority Queue in C++ STL

A **priority_queue** is a special type of queue where:

> The element with **highest priority** is served first.

### By default:
* It behaves as a **max heap**
* Largest element comes first

### ğŸ”¹ Types of Priority Queue

* **Max Heap** (default)
* **Min Heap** (using comparator)

### âœ… Max Heap Example
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq;

    pq.push(10);
    pq.push(40);
    pq.push(20);

    cout << pq.top(); // 40

    return 0;
}
```

### âœ… Min Heap Example
```cpp
priority_queue<int, vector<int>, greater<int>> pq;
```

### ğŸŸ¢ Where Priority Queue is Used?
* Dijkstraâ€™s algorithm
* Scheduling based on priority
* Heap-based problems
* Top K problems

## ğŸ” 9. Iterators in C++ STL

Iterators are **pointer-like objects** that allow us to traverse containers.

They act as a **bridge between containers and algorithms**.

### ğŸ”¹ Why Iterators Are Important?
* Algorithms donâ€™t work directly on containers
* Algorithms work on **iterator ranges**
* Makes STL flexible and generic

### ğŸ”¹ Common Iterator Functions
| Function   | Meaning                   |
| ---------- | ------------------------- |
| `begin()`  | Points to first element   |
| `end()`    | Points after last element |
| `rbegin()` | Reverse begin             |
| `rend()`   | Reverse end               |

### âœ… Example Code
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {10, 20, 30};

    for(auto it = v.begin(); it != v.end(); it++) {
        cout << *it << " ";
    }

    return 0;
}
```

## âš™ï¸ 10. STL Algorithms in C++

STL provides **ready-made algorithms** for common operations.

### ğŸ“Œ Header Files
```cpp
#include <algorithm>
#include <numeric>
```

### ğŸ”¹ Most Used STL Algorithms
#### ğŸ”¸ sort()

Sorts elements in ascending order.
```cpp
sort(v.begin(), v.end());
```

#### ğŸ”¸ binary_search()

Checks if element exists (only on sorted container).
```cpp
binary_search(v.begin(), v.end(), 20);
```

### ğŸ”¸ find()

Finds first occurrence of element.
```cpp
auto it = find(v.begin(), v.end(), 10);
```

### ğŸ”¸ count()

Counts occurrences of a value.
```cpp
count(v.begin(), v.end(), 5);
```

#### ğŸ”¸ reverse()

Reverses container.
```cpp
reverse(v.begin(), v.end());
```

#### ğŸ”¸ accumulate()

Finds sum of elements.
```cpp
int sum = accumulate(v.begin(), v.end(), 0);
```

#### ğŸ”¸ unique()

Removes consecutive duplicates.
```cpp
v.erase(unique(v.begin(), v.end()), v.end());
```

#### ğŸ”¸ lower_bound()

First element â‰¥ value.
```cpp
lower_bound(v.begin(), v.end(), x);
```

#### ğŸ”¸ upper_bound()

First element > value.
```cpp
upper_bound(v.begin(), v.end(), x);
```

#### ğŸ”¸ replace()

Replaces values.
```cpp
replace(v.begin(), v.end(), oldVal, newVal);
```

#### ğŸ”¸ next_permutation()

Generates next lexicographical permutation.
```cpp
next_permutation(v.begin(), v.end());
```

#### ğŸ”¸ __builtin_popcount()

Counts number of set bits.
```cpp
__builtin_popcount(15); // 4
```

#### ğŸ”¸ min_element() & max_element()
```cpp
*min_element(v.begin(), v.end());
*max_element(v.begin(), v.end());
```

## âœ… Benefits of C++ STL
| Benefit       | Explanation        |
| ------------- | ------------------ |
| â±ï¸ Saves Time | No need to code DS |
| ğŸ§ª Reliable   | Industry-tested    |
| âš¡ Fast        | Highly optimized   |
| â™»ï¸ Reusable   | Generic templates  |
| ğŸ§¼ Clean Code | Short & readable   |

## ğŸ¯ Final Takeaway

> **STL is the backbone of modern C++ programming.**

If you know:
* Containers
* Iterators
* Algorithms

You can solve **most DSA problems efficiently**.

ğŸ“Œ Mastering STL =
âœ” Faster coding
âœ” Cleaner logic
âœ” Strong interview performance

**ğŸ”¥ Strong STL knowledge turns average coders into confident problem solvers.**

---