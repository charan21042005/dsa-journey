# C++ Basics ‚Äì Detailed Notes

This document covers the **fundamental concepts of C++ programming**.
These basics form the foundation for **logic building and Data Structures & Algorithms**.

---

## üîπ Introduction to C++

C++ is a **general-purpose, compiled programming language** developed as an extension of C.
It supports:
- Procedural programming
- Object-Oriented Programming (OOP)
- Low-level memory manipulation
- High performance applications

C++ is widely used in:
- Competitive programming
- System software
- Game development
- Backend services
- Data Structures & Algorithms

A strong understanding of C++ basics is essential to write **efficient, optimized, and readable DSA solutions**.

---

## üîπ Basic C++ Program Structure

Below is a simple C++ program:

```cpp
#include <iostream>
using namespace std;

int main() {
    // This prints Hello World!
    cout << "Hello, World!";
    return 0;
}
```
---

Program Structure Visualization

Now let‚Äôs understand each line and component in detail.

1Ô∏è‚É£ Preprocessor Directives

#include <iostream>
* Lines starting with # are called preprocessor directives
* They are executed before compilation
* `#include` tells the compiler to include predefined code
* `<iostream>` is a header file that enables input and output operations


2Ô∏è‚É£ Header Files

Header files contain declarations of functions and objects.

* `iostream` provides:
  * `cout` ‚Üí output
  * `cin` ‚Üí input
* Without including `iostream`, input/output operations will not work


3Ô∏è‚É£ Namespace
```cpp
using namespace std;
```

* `std` is the standard namespace
* It contains standard objects like `cout`, `cin`, `endl`
* Using `using namespace std`; avoids writing `std::cout` repeatedly

Example without namespace
```cpp
std::cout << "Hello";
```

4Ô∏è‚É£ Main Function
```cpp
int main() {
    // code
}
```

* main() is the entry point of every C++ program
* Program execution always starts from main
* int indicates the function returns an integer value


5Ô∏è‚É£ Comments in C++
```cpp
// Single-line comment

/*
Multi-line
comment
*/
```

* Comments are ignored by the compiler
* Used to explain code and improve readability


6Ô∏è‚É£ Output Statement
```cpp
cout << "Hello, World!";
```
* `cout` is used to display output
* `<<` is called the insertion operator
* Text inside double quotes is printed as it is


7Ô∏è‚É£ Return Statement
```cpp
return 0;
```

* Returns control back to the operating system
* `0` indicates successful execution
* Required because `main()` has return type `int`

**C++ Program Structure**

![C++ Program Structure](../Images/1.Screenshot%202025-12-24%20132321.png)

---

## üîπ Data Types in C++

Data types specify:
- What **type of data** a variable can store
- How much **memory** is allocated
- What kind of **operations** can be performed on the data

Below is the classification of data types in C++.

![Data Types in C++](../Images/2.Screenshot%202025-12-24%20132414.png)

---

1Ô∏è‚É£ Character Data Type (`char`)

The `char` data type is used to store a **single character**.

```cpp
char grade = 'A';
```
Key points:
* Stores one character only
* Written inside single quotes
* Uses 1 byte of memory
* Internally stores ASCII values

```cpp
Example:

char ch = 'a';
cout << ch;
```
Common use cases:
* Characters
* Symbols
* Single letters

2Ô∏è‚É£ Integer Data Type (`int`)

The int data type is used to store whole numbers (positive or negative).
```cpp
int age = 20;
```
Key points:
* Stores numbers without decimal points
* Typically occupies 4 bytes
* Can store values like -10, 0, 100

Example:
```cpp
int a = 10;
int b = 20;
int sum = a + b;
cout << sum;
```
Used in:
* Counting
* Loop variables
* Indexing arrays

3Ô∏è‚É£ Boolean Data Type (`bool`)

The bool data type stores logical values.
```cpp
bool isPassed = true;
```
Key points:
* Can store only true or false
* Internally represented as:
  * true ‚Üí 1
  * false ‚Üí 0
* Uses 1 byte of memory

Example:
```cpp
bool isAdult = (age >= 18);
cout << isAdult;
```
Used in:
* Conditions
* Decision making
* Loops

4Ô∏è‚É£ Floating Point Data Type (`float`)

The `float` data type is used to store decimal numbers.
```cpp
float marks = 85.5;
```
Key points:
* Stores decimal values
* Single precision
* Less accurate than double
* Uses 4 bytes of memory

Example:
```cpp
float price = 99.99;
cout << price;
```
Used in:
* Measurements
* Percentages
* Approximate calculations

5Ô∏è‚É£ Double Data Type (`double`)

The `double` data type stores decimal numbers with higher precision.
```cpp
double salary = 45678.9876;
```
Key points:
* Double precision floating point
* More accurate than float
* Uses 8 bytes of memory

Example:
```cpp
double pi = 3.1415926535;
cout << pi;
```

Preferred over `float` when:
* Accuracy matters
* Large decimal values are used

6Ô∏è‚É£ Void Data Type (`void`)

The `void` data type represents no value.

It is mainly used with functions that **do not return anything**.
```cpp
void displayMessage() {
    cout << "Welcome to C++";
}
```
Key points:
* Indicates absence of a return value
* Cannot be used to declare normal variables
* Commonly used in function definitions

üîë Summary of Data Types
* `char` ‚Üí single character
* `int` ‚Üí whole numbers
* `bool` ‚Üí true/false values
* `floa`t ‚Üí decimal numbers (less precision)
* `double` ‚Üí decimal numbers (high precision)
* `void` ‚Üí no return value

Understanding data types is crucial for:
* Memory management
* Correct program behavior
* Writing efficient DSA solutions

---

## üîπ Type Safety in C++

C++ is a **type-safe language**, which means every variable must be used
according to its **declared data type**.

Type safety helps the compiler:
- Detect errors early (at compile time)
- Prevent invalid operations
- Avoid unexpected behavior at runtime

---

### Example of Type Safety

```cpp
int x = 10;
// x = "Hello";   ‚ùå Invalid
```
## üîπ Type Safety in C++

C++ is a **type-safe language**, which means every variable must be used
according to its **declared data type**.

Type safety helps the compiler:
- Detect errors early (at compile time)
- Prevent invalid operations
- Avoid unexpected behavior at runtime

### Example of Type Safety

```cpp
int x = 10;
// x = "Hello";   ‚ùå Invalid
```
Explanation:
* `x` is declared as an `int`
* Assigning a string to an integer variable is not allowed
* The compiler throws an error

Why Type Safety Matters
| Benefit          | Explanation                          |
| ---------------- | ------------------------------------ |
| Error prevention | Catches mistakes before program runs |
| Code reliability | Ensures correct operations on data   |
| Easier debugging | Errors are detected early            |
| Safer programs   | Prevents unintended data misuse      |

Type safety is especially important in DSA, where incorrect data usage
can completely break logic.

---

## üîπ Data Type Conversion

Data type conversion means converting a value from **one data type to another**.

C++ supports two types of conversion:
1. Implicit (Automatic)
2. Explicit (Type Casting)

1Ô∏è‚É£ Implicit Type Conversion (Automatic)

This conversion is done **automatically by the compiler**.
```cpp
int a = 10;
double b = a;   // int ‚Üí double
```
Explanation:
* Integer value `10` is automatically converted to `10.0`
* No data loss occurs
* Also called widening conversion

Characteristics of Implicit Conversion
| Feature   | Description                |
| --------- | -------------------------- |
| Automatic | Done by compiler           |
| Safe      | No data loss               |
| Widening  | Smaller ‚Üí larger data type |

2Ô∏è‚É£ Explicit Type Conversion (Type Casting)

Explicit conversion is done manually by the programmer.
```cpp
double x = 9.8;
int y = (int)x;
```
Explanation:
* Decimal part `.8` is discarded
* Result: `y = 9`
* Data loss may occur

Characteristics of Explicit Conversion
| Feature   | Description                    |
| --------- | ------------------------------ |
| Manual    | Programmer controls conversion |
| Risky     | Data loss possible             |
| Narrowing | Larger ‚Üí smaller data type     |

When to Use Explicit Conversion
* When precision loss is acceptable
* When logic demands integer values
* When compiler does not allow automatic conversion

---

## üîπ Size of Data Types in C++

C++ provides the `sizeof()` operator to find how much memory
a data type occupies (in bytes).

Example
```cpp
cout << sizeof(int);
cout << sizeof(char);
cout << sizeof(float);
cout << sizeof(double);
```
Common Data Type Sizes (Typical)
| Data Type | Size (Bytes) |
| --------- | ------------ |
| `char`    | 1            |
| `bool`    | 1            |
| `int`     | 4            |
| `float`   | 4            |
| `double`  | 8            |
| `void`    | No storage   |

> ‚ö†Ô∏è Note: Sizes may vary depending on system architecture and compiler.

Why Size Matters in DSA
* Efficient memory usage
* Optimizing space complexity
* Handling large inputs safely

---

## üîπ Data Type Modifiers

Data type modifiers are used to **modify the size or range of basic data types**.

They allow better control over memory and value range.

Common Data Type Modifiers
| Modifier   | Purpose                |
| ---------- | ---------------------- |
| `short`    | Reduces size           |
| `long`     | Increases size         |
| `signed`   | Allows negative values |
| `unsigned` | Only positive values   |

Examples of Modifiers
```cpp
short int x = 10;
long int distance = 123456789;
unsigned int count = 100;
signed int value = -20;
```
Comparison Example
| Data Type      | Range                           |
| -------------- | ------------------------------- |
| `int`          | ‚àí2,147,483,648 to 2,147,483,647 |
| `unsigned int` | 0 to 4,294,967,295              |

Why Modifiers Are Useful
* Save memory
* Extend numeric range
* Avoid negative values where unnecessary
* Improve performance in some cases

‚úÖ Summary
* Type safety ensures correct data usage
* Type conversion allows flexibility between data types
* `sizeof()` helps understand memory allocation
* Modifiers give control over size and range of values
These concepts are **critical for writing safe, optimized, and efficient C++ programs**,
especially when solving **DSA problems**.

---

## üîπ Variables in C++

A **variable** is a named memory location used to store data during program execution.
The value of a variable can **change** while the program is running.

Variables are fundamental in programming because they allow us to:
- Store input values
- Perform calculations
- Control program flow
- Store intermediate results

### üîπ Creating a Variable

Creating a variable involves **declaring** it with:
- A data type
- A variable name (identifier)

### Syntax

```cpp
data_type variable_name;
```
Examples
```cpp
int number;
float price;
char grade;
```
Components of a Variable
| Component     | Description                             |
| ------------- | --------------------------------------- |
| Data type     | Defines what type of data can be stored |
| Variable name | Identifier used to access the data      |
| Memory        | Space allocated based on data type      |

bool isValid;

### üîπ Initializing a Variable (Assignment Operator)

Initialization means assigning a value to a variable.

### Syntax
```cpp
variable_name = value;
```
or combined declaration and initialization:
```cpp
data_type variable_name = value;
```
Example
```cpp
int x = 10;
float marks = 85.5;
char grade = 'A';
```
**Assignment Operator (`=`)**
* Assigns the value on the right to the variable on the left
* Not a comparison operator

### üîπ Accessing and Updating Variables
Accessing a Variable
```cpp
int x = 10;
cout << x;
```
Updating a Variable
```cpp
int x = 5;
x = x + 2;   // x becomes 7
```
Variables can be updated multiple times during execution.

### üîπ Rules for Naming Variables (Identifiers)

Identifiers are the names given to variables.

**Rules**
* Must start with a letter (a‚Äìz, A‚ÄìZ) or underscore _
* Cannot start with a number
* No spaces allowed
* Cannot use C++ keywords
* Case-sensitive (count and Count are different)

Valid Identifiers
```cpp
int totalMarks;
int _count;
```
Invalid Identifiers
```cpp
int 1value;        // ‚ùå starts with number
int total marks;   // ‚ùå contains space
int float;         // ‚ùå keyword
float averageScore;
```
### üîπ How Are Variables Used?
Variables are used to:
* Store user input
* Perform arithmetic operations
* Control conditions and loops
* Store results temporarily

Example
```cpp
int a = 10;
int b = 20;
int sum = a + b;

cout << sum;
```
Without variables, programs would not be dynamic or flexible.

### üîπ Constant Variables
Constant variables store values that cannot be changed once assigned.
### Syntax
```cpp
const data_type variable_name = value;
```
Example
```cpp
const int MAX = 100;
```
Why Use Constants?
| Benefit     | Explanation                           |
| ----------- | ------------------------------------- |
| Safety      | Prevents accidental modification      |
| Readability | Makes code easier to understand       |
| Reliability | Ensures fixed values remain unchanged |

Trying to change a constant causes a compile-time error.

### üîπ Scope of Variables
Scope defines where a variable can be accessed in a program.
C++ supports multiple scopes.

1Ô∏è‚É£ Local Scope
```cpp
int main() {
    int x = 10;   // local variable
}
```
* Accessible only inside the function or block
* Destroyed after block execution

2Ô∏è‚É£ Global Scope
```cpp
int x = 5;

int main() {
    cout << x;
}

```
* Declared outside all functions
* Accessible throughout the program

3Ô∏è‚É£ Block Scope
```cpp
if (true) {
    int y = 20;
}
```
* Accessible only inside { }
* Common in loops and conditional statements

Scope Comparison Table
| Scope  | Lifetime           | Accessibility   |
| ------ | ------------------ | --------------- |
| Local  | Function execution | Inside function |
| Global | Entire program     | Anywhere        |
| Block  | Block execution    | Inside block    |


### üîπ Memory Management of Variables
Memory for variables is:
* Automatically allocated when declared
* Automatically deallocated when they go out of scope

Example
```cpp
int main() {
    int x = 10;   // memory allocated
}                // memory released
```
Memory Allocation Depends On
| Factor    | Impact                     |
| --------- | -------------------------- |
| Data type | Determines memory size     |
| Scope     | Determines lifetime        |
| Modifiers | Can increase/decrease size |

**Stack Memory (Basics)**
* Local variables are stored in stack memory
* Fast access
* Automatically managed
This automatic memory handling makes C++ efficient and powerful for DSA.

‚úÖ Summary
* Variables store and manipulate data
* Declaration defines type and memory
* Initialization assigns values
* Constants protect fixed values
* Scope controls visibility and lifetime
* Memory is managed automatically for basic variables

A strong understanding of variables is essential for:
* Logic building
* Writing clean code
* Solving DSA problems efficiently

---

## üîπ Constants in C++

A **constant** is a value that **cannot be changed during program execution**.
Once a constant is defined, its value remains fixed throughout the program.

Constants help in writing:
- Safer code
- More readable code
- More maintainable programs

---

## üîπ Why Constants Are Important

Using constants:
- Prevents accidental modification of values
- Makes the purpose of values clear
- Improves code reliability
- Helps avoid hard-coded magic numbers

### üîπ Types of Constants in C++

C++ supports multiple ways to define constants:

1. Using `const` keyword  
2. Using `constexpr` keyword  
3. Using `#define` preprocessor directive  

### 1Ô∏è‚É£ Using `const` Keyword

The `const` keyword is the **most commonly used** way to define constants in C++.

### Syntax

```cpp
const data_type constant_name = value;
```
Example
```cpp
const int MAX_STUDENTS = 60;
const float PI = 3.14;
```
Key Points
* Value cannot be modified after initialization
* Checked at compile time
* Has type safety
* Follows scope rules (local/global)

Attempting to modify a const variable:
```cpp
const int x = 10;
// x = 20;   ‚ùå Error
```

### 2Ô∏è‚É£ Using `constexpr` Keyword

`constexpr` is used for constants whose values are known at compile time.

### Syntax
```cpp
constexpr data_type constant_name = value;
```
Example
```cpp
constexpr int SIZE = 10;
```
Key Points
* Value must be determined at compile time
* Often used in performance-critical code
* Mostly used for expressions and functions evaluated at compile time

Example with expression:
```cpp
constexpr int area = 5 * 5;
```

### 3Ô∏è‚É£ Using `#define` Preprocessor Directive

`#define` creates a constant using the **preprocessor**, not the compiler.

### Syntax
```cpp
#define CONSTANT_NAME value
```

Example
```cpp
#define MAX 100
```

Characteristics
* No data type checking
* Simple text replacement
* Does not follow scope rules
* Used before compilation

Example:
```cpp
cout << MAX;
```

### üîπ Comparison of Constant Methods
| Method      | Type Safety | Scope | Compiler Checked |
| ----------- | ----------- | ----- | ---------------- |
| `const`     | Yes         | Yes   | Yes              |
| `constexpr` | Yes         | Yes   | Yes              |
| `#define`   | No          | No    | No               |

üëâ Best practice: Prefer `const` or `constexpr` over `#define`.

### üîπ Real-World Examples of Constants
Constants are used wherever values should never change.

Example 1: Mathematical Values
```cpp
const double PI = 3.14159;
```
Example 2: Application Limits
```cpp
const int MAX_LOGIN_ATTEMPTS = 3;
```
Example 3: Configuration Values
```cpp
const int PORT = 8080;
```
Example 4: Days in a Week
```cpp
const int DAYS_IN_WEEK = 7;
```
Using constants improves clarity and safety in real-world applications.

### üîπ Difference Between Constants and Literals
What Is a Literal?

A literal is a fixed value written directly in the code.
```cpp
10
3.14
'A'
"Hello"
```
Comparison: Constants vs Literals
| Feature          | Constants | Literals         |
| ---------------- | --------- | ---------------- |
| Can change value | ‚ùå No      | ‚ùå No             |
| Has a name       | ‚úÖ Yes     | ‚ùå No             |
| Readability      | High      | Low              |
| Reusability      | High      | Low              |
| Best practice    | Yes       | Avoid repetition |

Example Comparison
Using literals:
```cpp
int area = 3.14 * 5 * 5;
```
Using constants:
```cpp
const double PI = 3.14;
int area = PI * 5 * 5;
```
‚úÖ The second approach is clearer, safer, and reusable.

![Constants vs Literals](../Images/3.Screenshot%202025-12-24%20134105.png)

‚úÖ Summary
* Constants store fixed values
* `const` is the most preferred method
* `constexpr` is used for compile-time expressions
* `#define` should be avoided when possible
* Constants improve code quality and safety
* Constants are better than repeated literals

Understanding constants is essential for writing **clean, safe, and professional C++ code**,
especially in **DSA and real-world applications**.

---

## üîπ Type Inference in C++ (`auto` and `decltype`)

**Type inference** allows the compiler to automatically determine the data type of a variable
based on the value or expression assigned to it.

C++ introduced powerful type inference features to:
- Reduce code verbosity
- Improve readability
- Avoid type-related mistakes
- Simplify complex type declarations

The two main keywords used for type inference in C++ are:
- `auto`
- `decltype`

---

## üîπ `auto` in C++

The `auto` keyword tells the compiler to **automatically deduce the data type**
of a variable from its initializer.

### Basic Syntax
```cpp
auto variable_name = value;
```

Example
```cpp
auto x = 10;        // int
auto y = 3.14;      // double
auto z = 'A';       // char
```
The compiler deduces:
* `x` as `int`
* `y` as `double`
* `z` as `char`

### `auto` with Expressions
```cpp
int a = 5;
int b = 10;

auto sum = a + b;   // int
```
The type of `sum` is deduced from the expression `a + b`.

### auto with Containers (Very Useful)
```cpp
vector<int> nums = {1, 2, 3, 4};

for (auto it = nums.begin(); it != nums.end(); it++) {
    cout << *it << " ";
}
```
Without `auto`, the iterator type would be long and complex.

### Key Rules of `auto`
| Rule                                   | Explanation         |
| -------------------------------------- | ------------------- |
| Must be initialized                    | `auto x;` ‚ùå invalid |
| Type deduced at compile time           | No runtime overhead |
| Removes reference & const (by default) | Special cases apply |

### `auto` with `const`
```cpp
const int a = 10;
auto b = a;        // int (const removed)
const auto c = a;  // const int
```

---

## üîπ `decltype` in C++

The `decltype` keyword is used to **extract the exact data type of an expression**
without evaluating it.

Unlike `auto`, `decltype` does not require initialization.

**Basic Syntax**
```cpp
decltype(expression) variable_name;
```

Example
```cpp
int x = 10;
decltype(x) y = 20;   // y is int
```

**`decltype` with Expressions**
```cpp
int a = 5;
int b = 10;

decltype(a + b) sum;   // int
```
The compiler determines the type of `a + b` without executing it.

**`decltype` Preserves const and References**
```cpp
int x = 10;
int& ref = x;

decltype(ref) y = x;   // int&
```
This makes `decltype` very precise.

**Use Cases of `decltype`**
* Template programming
* Extracting return types
* Working with complex expressions
* Preserving exact types

**üîπ `auto` vs `decltype`**
| Feature                 | `auto`                 | `decltype`               |
| ----------------------- | ---------------------- | ------------------------ |
| Purpose                 | Deduce type from value | Get type from expression |
| Initialization required | Yes                    | No                       |
| Removes const/reference | Yes (by default)       | No                       |
| Used in                 | Variables, loops       | Templates, return types  |

Example Comparison
```cpp
int x = 10;
const int y = 20;

auto a = y;          // int
decltype(y) b = y;   // const int
```

## üîπ `decltype` vs `typeid`

The `typeid` operator is used to **identify the type at runtime**, whereas
`decltype` works entirely at compile time.

`typeid` Example
```cpp
#include <typeinfo>

int x = 10;
cout << typeid(x).name();
```
* Returns a compiler-dependent type name
* Used mainly for debugging

`decltype` Example
```cpp
int x = 10;
decltype(x) y = 20;
```
* Type known at compile time
* No runtime overhead

**Comparison Table: `decltype` vs `typeid`**
| Feature         | `decltype`              | `typeid`            |
| --------------- | ----------------------- | ------------------- |
| Evaluation time | Compile time            | Runtime             |
| Purpose         | Type deduction          | Type identification |
| Performance     | No overhead             | Runtime cost        |
| Common usage    | Templates, generic code | Debugging           |

## üîπ When to Use What?
| Scenario             | Recommended |
| -------------------- | ----------- |
| Loop iterators       | `auto`      |
| Complex return types | `decltype`  |
| Template programming | `decltype`  |
| Debugging types      | `typeid`    |

**‚úÖ Summary**
* Type inference simplifies C++ code
* `auto` deduces type from initializer
* `decltype` extracts exact type from expression
* `decltype` preserves const and references
* `typeid` is runtime-based and mainly for debugging

Understanding type inference is essential for **modern C++ programming**
and helps write **clean, maintainable, and generic code**, especially in DSA
and advanced C++ concepts.

---

## üîπ Basic Input / Output in C++

Input and Output (I/O) operations allow a program to:
- Take data from the user (input)
- Display results to the user (output)

C++ uses **streams** for input and output operations.
A stream is a flow of data between the program and an external device (keyboard, screen, file).

**üîπ Input / Output Streams in C++**

To use input and output streams, C++ provides the `<iostream>` header file.

```cpp
#include <iostream>
```

The `<iostream>` library provides:
* `cin` ‚Üí standard input stream
* `cout` ‚Üí standard output stream
* `cerr` ‚Üí un-buffered error output stream
`clog` ‚Üí buffered error output stream

### üîπ Standard Output Stream `(cout)`
`cout` is used to **display output** on the console.

It uses the **insertion operator `(<<)`** to send data to the output stream.

### Syntax
```cpp
cout << data;
```
Example
```cpp
cout << "Hello, World!";
```
Printing Multiple Values
```cpp
int x = 10;
float y = 5.5;

cout << "Value of x: " << x << ", Value of y: " << y;
```
### Using endl
```cpp
cout << "Hello" << endl;
cout << "World";
```
* `endl` moves the cursor to the next line
* It also flushes the output buffer

### Key Points about `cout`
| Feature       | Description               |
| ------------- | ------------------------- |
| Output stream | Sends data to screen      |
| Operator used | `<<` (insertion operator) |
| Part of       | `<iostream>`              |
| Buffered      | Yes                       |

### üîπ Standard Input Stream (cin)
`cin` is used to take input from the user through the keyboard.

It uses the extraction operator `(>>)` to read data from the input stream.
### Syntax
```cpp
cin >> variable;
```
Example
```cpp
int age;
cin >> age;
```
Taking Multiple Inputs
```cpp
int a, b;
```
### Input with Output
```cpp
int num;
cout << "Enter a number: ";
cin >> num;
```

### Key Points about `cin`
| Feature       | Description                         |
| ------------- | ----------------------------------- |
| Input stream  | Reads data from keyboard            |
| Operator used | `>>` (extraction operator)          |
| Stops reading | At whitespace (space, tab, newline) |
| Buffered      | Yes                                 |

cout << "You entered: " << num;
cin >> a >> b;
